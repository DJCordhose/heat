<html>

<head>
    <title>Topic Activity</title>
    <style>
        .parent {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            grid-template-rows: repeat(4, 1fr);
            grid-column-gap: 10px;
            grid-row-gap: 10px;
            width: 100%
        }

        div.box {
            /* width: 200px;
            height: 200px; */
            /* border-radius: 100px; */
            background-color: #f0f0f0;
        }


        div {
            padding: 10px;
            text-align: center;
        }


        .clicked {
            animation: glow 0.5s ease-in-out;
        }

        .headercol {
            text-align: center;
            font-weight: bold;
        }

        .headerrow {
            text-align: center;
            font-weight: bold;
        }

        @keyframes glow {
            from {
                box-shadow: 0 0 10px -10px #aef4af;
            }

            to {
                box-shadow: 0 0 10px 10px #aef4af;
            }
        }
    </style>
</head>

<body>
    <h1>Aktivit채ten</h1>
    <div style="width: 100%;">
        <section id='actors'
            style="display: none; grid-template-columns: repeat(7, 1fr); grid-template-rows: 30px; gap: 0px; width: 100%;">
        </section>
        <section id='tasks'
            style="display: none; float: left; grid-template-columns: repeat(5, 1fr); grid-template-rows: 50px; gap: 0px; height: 100%;">
        </section>
        <div class="parent" id="map"></div>
    </div>
    <script>
        // global
        let tasks;
        let actors;
        let meta;
        let topCount = 10;

        const counts = {};

        const minuteInMs = 1000 * 60;
        const hourInMs = minuteInMs * 60;
        const dayInMs = hourInMs * 24;
        const weekInMs = dayInMs * 7;
        const monthInMs = dayInMs * 30;

        // TODO: should be taken from config?
        const decayPeriod = minuteInMs;
        // const decayPeriod = monthInMs;

    </script>
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-app.js";

        const projectId = "embarc-heat";
        const firebaseConfig = {
            projectId
        };

        // Initialize Firebase
        const app = initializeApp(firebaseConfig);
        import { getFirestore, collection, query, where, getDocs, doc, getDoc, addDoc, deleteDoc, writeBatch } from "https://www.gstatic.com/firebasejs/9.6.1/firebase-firestore.js";
        const db = getFirestore();

        function el(html) {
            const template = document.createElement('template');
            template.innerHTML = html;
            return template.content.firstChild;
        }

        function glow(el) {
            el.classList.add('clicked');
            setTimeout(() => {
                el.classList.remove('clicked');
            }, 500);
        }

        function renderConfig() {
            const tasksHeader = document.getElementById('tasks');
            const actorsHeader = document.getElementById('actors');
            // const div = el(`<div class='headercol'></div>`);
            // actorsHeader.append(div);

            const map = document.getElementById('map');
            map.addEventListener('click', async function (e) {
                // console.log(e.clientX, e.clientY);
                // const x = e.offsetX;
                // const y = e.offsetY;
                // const x = e.clientX;
                // const y = e.clientY;
                // console.log(e.target)
                // const elem = el(`<div style="position: absolute; top: ${y}px; left: ${x}px; background: red; width: 10px; height: 10px;"></div>`);
                // map.appendChild(elem);

                const el = e.target;
                const id = el.id;
                const [actor, task] = id.split('_');
                if (task) {
                    // console.log(actor, task);
                    glow(el);

                    // optimistic update for quick response
                    const id = `${actor}_${task}`;
                    counts[id]++;
                    update();
                    try {
                        const docRef = await addDoc(collection(db, "pings"), {
                            actor,
                            task,
                            timestamp: Date.now(),
                            cnt: 1
                        });
                        // console.log("Document written with ID: ", docRef.id);
                    } catch (e) {
                        console.error("Error adding document: ", e);
                    }
                }
            });

            for (const taskIdx in tasks) {
                const task = tasks[taskIdx];
                const div = el(`<div class='headerrow'>${task}</div>`);
                tasksHeader.append(div)
            }

            for (const actorIdx in actors) {
                const actor = actors[actorIdx];
                const div = el(`<div class='headercol'>${actor}</div>`);
                // actorsHeader.append(div)
                map.append(div)
            }

            for (const taskIdx in tasks) {
                const task = tasks[taskIdx];
                for (const actorIdx in actors) {
                    const actor = actors[actorIdx];
                    const id = `${actor}_${task}`;
                    const div = el(`<div class='box' id="${id}">${actor}: ${task}</div>`);
                    map.append(div)
                }
            }
        }

        function configure(config) {
            tasks = config.tasks;
            actors = config.actors;
            meta = config.meta;
            if (config.topCount)
                topCount = config.topCount;
            renderConfig();
        }

        async function init() {
            // await removeDecayed();

            const docRef = doc(db, "config", "singleton");

            const docSnap = await getDoc(docRef);

            if (docSnap.exists()) {
                // console.log("Document data:", docSnap.data());
                configure(docSnap.data());
                await aggregate();
                update();
            } else {
                // doc.data() will be undefined in this case
                console.error("No such document!");
            }
        }

        function update() {
            const scaledCounts = transientScale();
            Object.entries(scaledCounts).forEach(([id, count]) => {
                const div = document.getElementById(id);
                // https://developer.mozilla.org/en-US/docs/Web/CSS/color_value/hsl()
                // https://drafts.csswg.org/css-color-3/#hsl-color
                div.style.backgroundColor = `hsl(120, ${count * 10 * 10 / topCount}%, 75%)`;
                const [actor, task] = id.split('_');

                // div.textContent = `${actor}: ${task}`;
                // div.textContent = `${actor}: ${task} (${counts[id]} Aktivit채ten pro Monat)`;
                // div.textContent = `${actor}: ${task} (${counts[id]} Aktivit채ten)`;
                // div.textContent = `${task} (${counts[id]} Aktivit채ten)`;
                div.textContent = `${task}`;
                // debug
                // div.textContent = `${id} (${count} / ${counts[id]})`;
            });
        }

        async function aggregate() {
            for (const taskIdx in tasks) {
                for (const actorIdx in actors) {
                    const id = `${actors[actorIdx]}_${tasks[taskIdx]}`;
                    counts[id] = 0;
                }
            }

            // https://firebase.google.com/docs/firestore/quickstart#read_data
            const querySnapshot = await getDocs(collection(db, "pings"));
            querySnapshot.forEach((doc) => {
                const { actor, task, timestamp, cnt } = doc.data();
                // console.log(`${doc.id} => ${actor}, ${task}, ${timestamp}`);
                const id = `${actor}_${task}`;
                counts[id] += cnt;
            });
        }

        // Non trivial properties (most likely logically not doable)
        // 1. The color of the box should be based on the number of clicks
        // 2. When a user clicks, they should be able to perceive a clear increase in color (perceived as positive feedback)
        // 3. Clicks must not overflow, i.e. there should always be an increase no matter how many times they click
        // 4. When reloading the application the color of the boxes should be same as when the application was closed (given no one else added clicks in the meantime)
        // 5. When the rate of clicks decays, the color of the boxes should be darker
        // 
        // Constraints:
        // 1. Expect at most one click per topic per session
        // 2. When reloading all colors are rescaled, possibly giving slightly different hue
        //
        // Solution:
        // 1. When max clicks < 10 do not scale, otherwise
        // 2. Scaled by 10 / max clicks
        // 3. Round, but never let one click be zero
        // 4. Add a visual trick to make the topic glow for a second, no one will notice if the color really changed
        function transientScale() {
            const max = Object.values(counts).reduce((a, b) => Math.max(a, b));
            if (max <= topCount) {
                return counts;
            }
            const scaledCounts = {};
            Object.entries(counts).forEach(([id, count]) => {
                let scaled;
                scaled = Math.ceil(count / max * topCount);
                scaledCounts[id] = scaled;
            });
            return scaledCounts;
        }

        // remove activities no longer relevant
        // rolling window
        async function removeDecayed() {
            const cutOffTimestamp = Date.now() - decayPeriod;

            // FIXME: does not work when working on data read 
            // do all detetes in on batch
            // const batch = writeBatch(db);

            let removedPings = 0
            const q = query(collection(db, "pings"), where("timestamp", "<", cutOffTimestamp));
            const querySnapshot = await getDocs(q);
            await Promise.all(
                querySnapshot.docs.map((doc) => {
                    // batch.delete(doc);
                    removedPings++;
                    return deleteDoc(doc.ref);
                }));

            console.log(`Removed ${removedPings} outdated pings`);
            // await batch.commit();
        }

        init();
    </script>

</body>

</html>